
@inproceedings{rasthofer_making_2017,
	location = {Buenos Aires},
	title = {Making Malory Behave Maliciously: Targeted Fuzzing of Android Execution Environments},
	isbn = {978-1-5386-3868-2},
	url = {http://ieeexplore.ieee.org/document/7985671/},
	doi = {10.1109/ICSE.2017.35},
	shorttitle = {Making Malory Behave Maliciously},
	abstract = {Android applications, or apps, provide useful features to end-users, but many apps also contain malicious behavior. Modern malware makes understanding such behavior challenging by behaving maliciously only under particular conditions. For example, a malware app may check whether it runs on a real device and not an emulator, in a particular country, and alongside a speciﬁc target app, such as a vulnerable banking app. To observe the malicious behavior, a security analyst must ﬁnd out and emulate all these app-speciﬁc constraints. This paper presents {FuzzDroid}, a framework for automatically generating an Android execution environment where an app exposes its malicious behavior. The key idea is to combine an extensible set of static and dynamic analyses through a search-based algorithm that steers the app toward a conﬁgurable target location. On recent malware, the approach reaches the target location in 75\% of the apps. In total, we reach 240 code locations within an average time of only one minute. To reach these code locations, {FuzzDroid} generates 106 different environments, too many for a human analyst to create manually.},
	eventtitle = {2017 {IEEE}/{ACM} 39th International Conference on Software Engineering ({ICSE})},
	pages = {300--311},
	booktitle = {2017 {IEEE}/{ACM} 39th International Conference on Software Engineering ({ICSE})},
	publisher = {{IEEE}},
	author = {Rasthofer, Siegfried and Arzt, Steven and Triller, Stefan and Pradel, Michael},
	urldate = {2019-02-04},
	date = {2017-05},
	langid = {english},
	file = {Rasthofer et al. - 2017 - Making Malory Behave Maliciously Targeted Fuzzing.pdf:C\:\\Users\\Standard\\Zotero\\storage\\ULP2MQH5\\Rasthofer et al. - 2017 - Making Malory Behave Maliciously Targeted Fuzzing.pdf:application/pdf}
}

@article{liang_fuzzing:_2018,
	title = {Fuzzing: State of the Art},
	volume = {67},
	issn = {0018-9529},
	doi = {10.1109/TR.2018.2834476},
	shorttitle = {Fuzzing},
	abstract = {As one of the most popular software testing techniques, fuzzing can find a variety of weaknesses in a program, such as software bugs and vulnerabilities, by generating numerous test inputs. Due to its effectiveness, fuzzing is regarded as a valuable bug hunting method. In this paper, we present an overview of fuzzing that concentrates on its general process, as well as classifications, followed by detailed discussion of the key obstacles and some state-of-the-art technologies which aim to overcome or mitigate these obstacles. We further investigate and classify several widely used fuzzing tools. Our primary goal is to equip the stakeholder with a better understanding of fuzzing and the potential solutions for improving fuzzing methods in the spectrum of software testing and security. To inspire future research, we also predict some future directions with regard to fuzzing.},
	pages = {1199--1218},
	number = {3},
	journaltitle = {{IEEE} Transactions on Reliability},
	author = {Liang, H. and Pei, X. and Jia, X. and Shen, W. and Zhang, J.},
	date = {2018-09},
	keywords = {Computer bugs, Security, software testing, Software testing, security, Fuzzing, reliability, survey},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Standard\\Zotero\\storage\\75XHMFKU\\8371326.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Standard\\Zotero\\storage\\P7ETY465\\Liang et al. - 2018 - Fuzzing State of the Art.pdf:application/pdf}
}

@article{mirzaei_testing_2012,
	title = {Testing android apps through symbolic execution},
	volume = {37},
	issn = {01635948},
	url = {http://dl.acm.org/citation.cfm?doid=2382756.2382798},
	doi = {10.1145/2382756.2382798},
	abstract = {There is a growing need for automated testing techniques aimed at Android apps. A critical challenge is the systematic generation of test cases. One method of systematically generating test cases for Java programs is symbolic execution. But applying symbolic execution tools, such as Symbolic Pathfinder ({SPF}), to generate test cases for Android apps is challenged by the fact that Android apps run on the Dalvik Virtual Machine ({DVM}) instead of {JVM}. In addition, Android apps are event driven and susceptible to path-divergence due to their reliance on an application development framework. This paper provides an overview of a two-pronged approach to alleviate these issues. First, we have developed a model of Android libraries in Java Pathfinder ({JPF}) to enable execution of Android apps in a way that addresses the issues of incompatibility with {JVM} and path-divergence. Second, we have leveraged program analysis techniques to correlate events with their handlers for automatically generating Android-specific drivers that simulate all valid events.},
	pages = {1},
	number = {6},
	journaltitle = {{ACM} {SIGSOFT} Software Engineering Notes},
	author = {Mirzaei, Nariman and Malek, Sam and Păsăreanu, Corina S. and Esfahani, Naeem and Mahmood, Riyadh},
	urldate = {2019-02-04},
	date = {2012-11-27},
	langid = {english},
	file = {Mirzaei et al. - 2012 - Testing android apps through symbolic execution.pdf:C\:\\Users\\Standard\\Zotero\\storage\\5S9V2IHS\\Mirzaei et al. - 2012 - Testing android apps through symbolic execution.pdf:application/pdf}
}

@inproceedings{mao_sapienz:_2016,
	location = {Saarbr\&\#252;cken, Germany},
	title = {Sapienz: multi-objective automated testing for Android applications},
	isbn = {978-1-4503-4390-9},
	url = {http://dl.acm.org/citation.cfm?doid=2931037.2931054},
	doi = {10.1145/2931037.2931054},
	shorttitle = {Sapienz},
	abstract = {We introduce Sapienz, an approach to Android testing that uses multi-objective search-based testing to automatically explore and optimise test sequences, minimising length, while simultaneously maximising coverage and fault revelation. Sapienz combines random fuzzing, systematic and search-based exploration, exploiting seeding and multi-level instrumentation. Sapienz signiﬁcantly outperforms (with large eﬀect size) both the state-of-the-art technique Dynodroid and the widely-used tool, Android Monkey, in 7/10 experiments for coverage, 7/10 for fault detection and 10/10 for fault-revealing sequence length. When applied to the top 1,000 Google Play apps, Sapienz found 558 unique, previously unknown crashes. So far we have managed to make contact with the developers of 27 crashing apps. Of these, 14 have conﬁrmed that the crashes are caused by real faults. Of those 14, six already have developer-conﬁrmed ﬁxes.},
	eventtitle = {the 25th International Symposium},
	pages = {94--105},
	booktitle = {Proceedings of the 25th International Symposium on Software Testing and Analysis - {ISSTA} 2016},
	publisher = {{ACM} Press},
	author = {Mao, Ke and Harman, Mark and Jia, Yue},
	urldate = {2019-02-04},
	date = {2016},
	langid = {english},
	file = {Mao et al. - 2016 - Sapienz multi-objective automated testing for And.pdf:C\:\\Users\\Standard\\Zotero\\storage\\MW7FHL84\\Mao et al. - 2016 - Sapienz multi-objective automated testing for And.pdf:application/pdf}
}

@inproceedings{mirzaei_reducing_2016,
	location = {Austin, Texas},
	title = {Reducing combinatorics in {GUI} testing of android applications},
	isbn = {978-1-4503-3900-1},
	url = {http://dl.acm.org/citation.cfm?doid=2884781.2884853},
	doi = {10.1145/2884781.2884853},
	abstract = {The rising popularity of Android and the {GUI}-driven nature of its apps have motivated the need for applicable automated {GUI} testing techniques. Although exhaustive testing of all possible combinations is the ideal upper bound in combinatorial testing, it is often infeasible, due to the combinatorial explosion of test cases. This paper presents {TrimDroid}, a framework for {GUI} testing of Android apps that uses a novel strategy to generate tests in a combinatorial, yet scalable, fashion. It is backed with automated program analysis and formally rigorous test generation engines. {TrimDroid} relies on program analysis to extract formal speciﬁcations. These speciﬁcations express the app’s behavior (i.e., control ﬂow between the various app screens) as well as the {GUI} elements and their dependencies. The dependencies among the {GUI} elements comprising the app are used to reduce the number of combinations with the help of a solver. Our experiments have corroborated {TrimDroid}’s ability to achieve a comparable coverage as that possible under exhaustive {GUI} testing using signiﬁcantly fewer test cases.},
	eventtitle = {the 38th International Conference},
	pages = {559--570},
	booktitle = {Proceedings of the 38th International Conference on Software Engineering - {ICSE} '16},
	publisher = {{ACM} Press},
	author = {Mirzaei, Nariman and Garcia, Joshua and Bagheri, Hamid and Sadeghi, Alireza and Malek, Sam},
	urldate = {2019-02-04},
	date = {2016},
	langid = {english},
	file = {Mirzaei et al. - 2016 - Reducing combinatorics in GUI testing of android a.pdf:C\:\\Users\\Standard\\Zotero\\storage\\GPGQ82RK\\Mirzaei et al. - 2016 - Reducing combinatorics in GUI testing of android a.pdf:application/pdf}
}

@article{linares-vasquez_enabling_2017,
	title = {Enabling Mutation Testing for Android Apps},
	url = {http://arxiv.org/abs/1707.09038},
	doi = {10.1145/3106237.3106275},
	abstract = {Mutation testing has been widely used to assess the fault-detection effectiveness of a test suite, as well as to guide test case generation or prioritization. Empirical studies have shown that, while mutants are generally representative of real faults, an effective application of mutation testing requires “traditional" operators designed for programming languages to be augmented with operators specific to an application domain and/or technology. This paper proposes {MDroid}+, a framework for effective mutation testing of Android apps. First, we systematically devise a taxonomy of 262 types of Android faults grouped in 14 categories by manually analyzing 2,023 software artifacts from different sources (e.g., bug reports, commits). Then, we identified a set of 38 mutation operators, and implemented an infrastructure to automatically seed mutations in Android apps with 35 of the identified operators. The taxonomy and the proposed operators have been evaluated in terms of stillborn/trivial mutants generated and their capacity to represent real faults in Android apps, as compared to other well know mutation tools.},
	pages = {233--244},
	journaltitle = {Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering  - {ESEC}/{FSE} 2017},
	author = {Linares-Vásquez, Mario and Bavota, Gabriele and Tufano, Michele and Moran, Kevin and Di Penta, Massimiliano and Vendome, Christopher and Bernal-Cárdenas, Carlos and Poshyvanyk, Denys},
	urldate = {2019-02-04},
	date = {2017},
	langid = {english},
	eprinttype = {arxiv},
	eprint = {1707.09038},
	keywords = {Computer Science - Software Engineering},
	file = {1707.09038.pdf:C\:\\Users\\Standard\\Zotero\\storage\\8WBRCRNA\\1707.09038.pdf:application/pdf}
}

@inproceedings{moran_automatically_2016,
	title = {Automatically Discovering, Reporting and Reproducing Android Application Crashes},
	doi = {10.1109/ICST.2016.34},
	abstract = {Mobile developers face unique challenges when detecting and reporting crashes in apps due to their prevailing {GUI} event-driven nature and additional sources of inputs (e.g., sensor readings). To support developers in these tasks, we introduce a novel, automated approach called {CRASHSCOPE}. This tool explores a given Android app using systematic input generation, according to several strategies informed by static and dynamic analyses, with the intrinsic goal of triggering crashes. When a crash is detected, {CRASHSCOPE} generates an augmented crash report containing screenshots, detailed crash reproduction steps, the captured exception stack trace, and a fully replayable script that automatically reproduces the crash on a target device(s). We evaluated {CRASHSCOPE}'s effectiveness in discovering crashes as compared to five state-of-the-art Android input generation tools on 61 applications. The results demonstrate that {CRASHSCOPE} performs about as well as current tools for detecting crashes and provides more detailed fault information. Additionally, in a study analyzing eight real-world Android app crashes, we found that {CRASHSCOPE}'s reports are easily readable and allow for reliable reproduction of crashes by presenting more explicit information than human written reports.},
	eventtitle = {2016 {IEEE} International Conference on Software Testing, Verification and Validation ({ICST})},
	pages = {33--44},
	booktitle = {2016 {IEEE} International Conference on Software Testing, Verification and Validation ({ICST})},
	author = {Moran, K. and Linares-Vásquez, M. and Bernal-Cárdenas, C. and Vendome, C. and Poshyvanyk, D.},
	date = {2016-04},
	keywords = {Android (operating system), Androids, Humanoid robots, mobile computing, graphical user interfaces, Computer crashes, crash reports, program diagnostics, systematic input generation, Testing, Graphical user interfaces, mobile developers, Systematics, Mobile communication, android, Android application crashes, crash reproduction steps, {CRASHSCOPE}, dynamic analyses, exception stack trace, fault information, {GUI} event-driven nature, {GUI}-testing, human written reports, static analyses},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Standard\\Zotero\\storage\\QIZM7WKF\\7515457.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Standard\\Zotero\\storage\\YJFMNJTS\\Moran et al. - 2016 - Automatically Discovering, Reporting and Reproduci.pdf:application/pdf}
}

@inproceedings{liu_automatic_2017,
	location = {Buenos Aires},
	title = {Automatic Text Input Generation for Mobile Testing},
	isbn = {978-1-5386-3868-2},
	url = {http://ieeexplore.ieee.org/document/7985701/},
	doi = {10.1109/ICSE.2017.65},
	abstract = {Many designs have been proposed to improve the automated mobile testing. Despite these improvements, providing appropriate text inputs remains a prominent obstacle, which hinders the large-scale adoption of automated testing approaches. The key challenge is how to automatically produce the most relevant text in a use case context. For example, a valid website address should be entered in the address bar of a mobile browser app to continue the testing of the app; a singer’s name should be entered in the search bar of a music recommendation app. Without the proper text inputs, the testing would get stuck. We propose a novel deep learning based approach to address the challenge, which reduces the problem to a minimization problem. Another challenge is how to make the approach generally applicable to both the trained apps and the untrained apps. We leverage the Word2Vec model to address the challenge. We have built our approaches as a tool and evaluated it with 50 {iOS} mobile apps including Firefox and Wikipedia. The results show that our approach signiﬁcantly outperforms existing automatic text input generation methods.},
	eventtitle = {2017 {IEEE}/{ACM} 39th International Conference on Software Engineering ({ICSE})},
	pages = {643--653},
	booktitle = {2017 {IEEE}/{ACM} 39th International Conference on Software Engineering ({ICSE})},
	publisher = {{IEEE}},
	author = {Liu, Peng and Zhang, Xiangyu and Pistoia, Marco and Zheng, Yunhui and Marques, Manoel and Zeng, Lingfei},
	urldate = {2019-02-04},
	date = {2017-05},
	langid = {english},
	file = {Liu et al. - 2017 - Automatic Text Input Generation for Mobile Testing.pdf:C\:\\Users\\Standard\\Zotero\\storage\\HQUDYK5Y\\Liu et al. - 2017 - Automatic Text Input Generation for Mobile Testing.pdf:application/pdf}
}

@inproceedings{mcafee_cate:_2017,
	location = {Buenos Aires, Argentina},
	title = {{CATE}: Concolic Android Testing Using Java {PathFinder} for Android Applications},
	isbn = {978-1-5386-2669-6},
	url = {http://ieeexplore.ieee.org/document/7972811/},
	doi = {10.1109/MOBILESoft.2017.35},
	shorttitle = {{CATE}},
	abstract = {Like all software systems, Android applications are not immune to bugs, security vulnerabilities, and a wide range of other runtime errors. Concolic analysis, a hybrid software veriﬁcation technique which performs symbolic execution along with a concrete execution path, has been used for a variety of purposes including software testing, code clone detection, and security-related activities. We created a new publicly available concolic analysis tool for analyzing Android applications: Concolic Android {TEster} ({CATE}). Building on Java Path Finder ({JPF}-{SPF}), this tool performs concolic analysis on a raw Android application ﬁle (or source code) and provides output in a useful and easy to understand format.},
	eventtitle = {2017 {IEEE}/{ACM} 4th International Conference on Mobile Software Engineering and Systems ({MOBILESoft})},
	pages = {213--214},
	booktitle = {2017 {IEEE}/{ACM} 4th International Conference on Mobile Software Engineering and Systems ({MOBILESoft})},
	publisher = {{IEEE}},
	author = {{McAfee}, Patrick and Wiem Mkaouer, Mohamed and Krutz, Daniel E.},
	urldate = {2019-02-04},
	date = {2017-05},
	langid = {english},
	file = {McAfee et al. - 2017 - CATE Concolic Android Testing Using Java PathFind.pdf:C\:\\Users\\Standard\\Zotero\\storage\\XGDKTBXN\\McAfee et al. - 2017 - CATE Concolic Android Testing Using Java PathFind.pdf:application/pdf}
}

@inproceedings{iannillo_chizpurfle:_2017,
	title = {Chizpurfle: A Gray-Box Android Fuzzer for Vendor Service Customizations},
	doi = {10.1109/ISSRE.2017.16},
	shorttitle = {Chizpurfle},
	abstract = {Android has become the most popular mobile {OS}, as it enables device manufacturers to introduce customizations to compete with value-added services. However, customizations make the {OS} less dependable and secure, since they can introduce software flaws. Such flaws can be found by using fuzzing, a popular testing technique among security researchers.This paper presents Chizpurfle, a novel "gray-box" fuzzing tool for vendor-specific Android services. Testing these services is challenging for existing tools, since vendors do not provide source code and the services cannot be run on a device emulator. Chizpurfle has been designed to run on an unmodified Android {OS} on an actual device. The tool automatically discovers, fuzzes, and profiles proprietary services. This work evaluates the applicability and performance of Chizpurfle on the Samsung Galaxy S6 Edge, and discusses software bugs found in privileged vendor services.},
	eventtitle = {2017 {IEEE} 28th International Symposium on Software Reliability Engineering ({ISSRE})},
	pages = {1--11},
	booktitle = {2017 {IEEE} 28th International Symposium on Software Reliability Engineering ({ISSRE})},
	author = {Iannillo, A. K. and Natella, R. and Cotroneo, D. and Nita-Rotaru, C.},
	date = {2017-10},
	keywords = {Tools, Android (operating system), Androids, Humanoid robots, mobile computing, program testing, fuzzing, Software, program debugging, security of data, Android {OS}, Chizpurfle, device emulator, device manufacturers, fuzzing tool, gray-box Android fuzzer, novel gray-box, popular mobile {OS}, popular testing technique, privileged vendor services, proprietary services, robustness testing, Samsung Galaxy S6 Edge, security researchers, Smart phones, software bugs, software flaws, unmodified Android {OS}, value-added services, vendor customizations, vendor service customizations, vendor-specific Android services},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Standard\\Zotero\\storage\\UAAWIZYT\\8109068.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Standard\\Zotero\\storage\\748ZTS9B\\Iannillo et al. - 2017 - Chizpurfle A Gray-Box Android Fuzzer for Vendor S.pdf:application/pdf}
}

@inproceedings{cheng_tainttrace:_2006,
	location = {Cagliari, Italy},
	title = {{TaintTrace}: Efficient Flow Tracing with Dynamic Binary Rewriting},
	isbn = {978-0-7695-2588-4},
	url = {http://ieeexplore.ieee.org/document/1691114/},
	doi = {10.1109/ISCC.2006.158},
	shorttitle = {{TaintTrace}},
	abstract = {{TaintTrace} is a high performance ﬂow tracing tool that protects systems against security exploits. It is based on dynamic execution binary rewriting empowering our tool with ﬁne-grained monitoring of system activities such as the tracking of the usage and propagation of data originated from the network. The challenge lies in minimizing the run-time overhead of the tool. {TaintTrace} uses a number of techniques such as direct memory mapping to optimize performance. In this paper, we demonstrate that {TaintTrace} is effective in protecting against various attacks while maintaining a modest slowdown of 5.5 times, offering signiﬁcant improvements over similar tools.},
	eventtitle = {11th {IEEE} Symposium on Computers and Communications ({ISCC}'06)},
	pages = {749--754},
	booktitle = {11th {IEEE} Symposium on Computers and Communications ({ISCC}'06)},
	publisher = {{IEEE}},
	author = {Cheng, W. and {Qin Zhao} and {Bei Yu} and Hiroshige, S.},
	urldate = {2019-02-19},
	date = {2006},
	langid = {english},
	file = {Cheng et al. - 2006 - TaintTrace Efficient Flow Tracing with Dynamic Bi.pdf:C\:\\Users\\Standard\\Zotero\\storage\\5CV38DQC\\Cheng et al. - 2006 - TaintTrace Efficient Flow Tracing with Dynamic Bi.pdf:application/pdf}
}